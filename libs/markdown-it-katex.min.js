/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@vscode/markdown-it-katex@1.1.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";
var __importDefault =
    (this && this.__importDefault) ||
    function (e) {
        return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(exports, "__esModule", { value: !0 });
const katex_1 = __importDefault(require("katex"));
function isValidInlineDelim(e, t) {
    const n = e.src[t - 1],
        r = e.src[t],
        l = e.src[t + 1];
    if ("$" !== r) return { can_open: !1, can_close: !1 };
    let s = !1,
        c = !1;
    return (
        "$" === n ||
            "\\" === n ||
            (void 0 !== n && !isWhitespace(n) && isWordCharacterOrNumber(n)) ||
            (s = !0),
        "$" === l ||
            (null != l && !isWhitespace(l) && isWordCharacterOrNumber(l)) ||
            (c = !0),
        { can_open: s, can_close: c }
    );
}
function isWhitespace(e) {
    return /^\s$/u.test(e);
}
function isWordCharacterOrNumber(e) {
    return /^[\w\d]$/u.test(e);
}
function isValidBlockDelim(e, t) {
    const n = e.src[t - 1],
        r = e.src[t],
        l = e.src[t + 1],
        s = e.src[t + 2];
    return "$" === r && "$" !== n && "\\" !== n && "$" === l && "$" !== s
        ? { can_open: !0, can_close: !0 }
        : { can_open: !1, can_close: !1 };
}
function inlineMath(e, t) {
    if ("$" !== e.src[e.pos]) return !1;
    const n = e.tokens.at(-1);
    if ("html_inline" === n?.type && /^<\w+.+[^/]>$/.test(n.content)) return !1;
    let r = isValidInlineDelim(e, e.pos);
    if (!r.can_open) return t || (e.pending += "$"), (e.pos += 1), !0;
    let l,
        s = e.pos + 1,
        c = s;
    for (; -1 !== (c = e.src.indexOf("$", c)); ) {
        for (l = c - 1; "\\" === e.src[l]; ) l -= 1;
        if ((c - l) % 2 == 1) break;
        c += 1;
    }
    if (-1 === c) return t || (e.pending += "$"), (e.pos = s), !0;
    if (c - s == 0) return t || (e.pending += "$$"), (e.pos = s + 1), !0;
    if (((r = isValidInlineDelim(e, c)), !r.can_close))
        return t || (e.pending += "$"), (e.pos = s), !0;
    if (!t) {
        const t = e.push("math_inline", "math", 0);
        (t.markup = "$"), (t.content = e.src.slice(s, c));
    }
    return (e.pos = c + 1), !0;
}
function blockMath(e, t, n, r) {
    var l,
        s,
        c,
        i,
        o = !1,
        a = e.bMarks[t] + e.tShift[t],
        u = e.eMarks[t];
    if (a + 2 > u) return !1;
    if ("$$" !== e.src.slice(a, a + 2)) return !1;
    a += 2;
    let h = e.src.slice(a, u);
    if (r) return !0;
    for (
        "$$" === h.trim().slice(-2) && ((h = h.trim().slice(0, -2)), (o = !0)),
            s = t;
        !o &&
        !(++s >= n) &&
        !(
            (a = e.bMarks[s] + e.tShift[s]) < (u = e.eMarks[s]) &&
            e.tShift[s] < e.blkIndent
        );

    )
        "$$" === e.src.slice(a, u).trim().slice(-2)
            ? ((c = e.src.slice(0, u).lastIndexOf("$$")),
              (l = e.src.slice(a, c)),
              (o = !0))
            : e.src.slice(a, u).trim().includes("$$") &&
              ((c = e.src.slice(0, u).trim().indexOf("$$")),
              (l = e.src.slice(a, c)),
              (o = !0));
    return (
        (e.line = s + 1),
        ((i = e.push("math_block", "math", 0)).block = !0),
        (i.content =
            (h && h.trim() ? h + "\n" : "") +
            e.getLines(t + 1, s, e.tShift[t], !0) +
            (l && l.trim() ? l : "")),
        (i.map = [t, e.line]),
        (i.markup = "$$"),
        !0
    );
}
function blockBareMath(e, t, n, r) {
    const l = e.bMarks[t] + e.tShift[t],
        s = e.eMarks[t];
    if (!e.src.slice(l, s).match(/^\s*\\begin\s*\{([^{}]+)\}/)) return !1;
    if (t > 0) {
        const n = e.bMarks[t - 1] + e.tShift[t - 1],
            r = e.eMarks[t - 1],
            l = e.src.slice(n, r);
        if (!/^\s*$/.test(l)) return !1;
    }
    if (r) return !0;
    const c = [];
    let i,
        o = t,
        a = !1;
    e: for (; !a && !(o >= n); o++) {
        const t = e.bMarks[o] + e.tShift[o],
            n = e.eMarks[o];
        if (t < n && e.tShift[o] < e.blkIndent) break;
        const r = e.src.slice(t, n);
        for (const l of r.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
            if ("\\begin" === l[1]) c.push(l[2].trim());
            else if ("\\end" === l[1] && (c.pop(), !c.length)) {
                (i = e.src.slice(t, n)), (a = !0);
                break e;
            }
    }
    e.line = o + 1;
    const u = e.push("math_block", "math", 0);
    return (
        (u.block = !0),
        (u.content = (e.getLines(t, o, e.tShift[t], !0) + (i ?? "")).trim()),
        (u.map = [t, e.line]),
        (u.markup = "$$"),
        !0
    );
}
function inlineMathBlock(e, t) {
    var n, r, l, s;
    if ("$$" !== e.src.slice(e.pos, e.pos + 2)) return !1;
    if (!isValidBlockDelim(e, e.pos).can_open)
        return t || (e.pending += "$$"), (e.pos += 2), !0;
    for (r = n = e.pos + 2; -1 !== (r = e.src.indexOf("$$", r)); ) {
        for (s = r - 1; "\\" === e.src[s]; ) s -= 1;
        if ((r - s) % 2 == 1) break;
        r += 2;
    }
    return -1 === r
        ? (t || (e.pending += "$$"), (e.pos = n), !0)
        : r - n == 0
        ? (t || (e.pending += "$$$$"), (e.pos = n + 2), !0)
        : isValidBlockDelim(e, r).can_close
        ? (t ||
              (((l = e.push("math_block", "math", 0)).block = !0),
              (l.markup = "$$"),
              (l.content = e.src.slice(n, r))),
          (e.pos = r + 2),
          !0)
        : (t || (e.pending += "$$"), (e.pos = n), !0);
}
function inlineBareBlock(e, t) {
    const n = e.src.slice(e.pos);
    if (!/^\n\\begin/.test(n)) return !1;
    if (((e.pos += 1), t)) return !0;
    const r = n.split(/\n/g).slice(1);
    let l;
    const s = [];
    e: for (var c = 0; c < r.length; ++c) {
        const e = r[c];
        for (const t of e.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
            if ("\\begin" === t[1]) s.push(t[2].trim());
            else if ("\\end" === t[1] && (s.pop(), !s.length)) {
                l = c;
                break e;
            }
    }
    if (void 0 === l) return !1;
    const i = r.slice(0, l + 1).reduce((e, t) => e + t.length, 0) + l + 1,
        o = e.push("math_inline_bare_block", "math", 0);
    return (
        (o.block = !0),
        (o.markup = "$$"),
        (o.content = n.slice(1, i)),
        (e.pos = e.pos + i),
        !0
    );
}
function handleMathInHtml(e, t, n, r) {
    const l = e.tokens;
    for (let e = l.length - 1; e >= 0; e--) {
        const s = l[e],
            c = [];
        if ("html_block" !== s.type) continue;
        const i = s.content;
        for (const e of i.matchAll(r)) {
            if (!e.groups) continue;
            const r = e.groups.html_before_math,
                l = e.groups.math,
                i = e.groups.html_after_math;
            r && c.push({ ...s, type: "html_block", map: null, content: r }),
                l &&
                    c.push({
                        ...s,
                        type: t,
                        map: null,
                        content: l,
                        markup: n,
                        block: !0,
                        tag: "math",
                    }),
                i &&
                    c.push({ ...s, type: "html_block", map: null, content: i });
        }
        c.length > 0 && l.splice(e, 1, ...c);
    }
    return !0;
}
function escapeHtml(e) {
    return e
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
function default_1(e, t) {
    const n = t?.enableBareBlocks,
        r = t?.enableMathBlockInHtml,
        l = t?.enableMathInlineInHtml,
        s = t?.enableFencedBlocks;
    e.inline.ruler.after("escape", "math_inline", inlineMath),
        e.inline.ruler.after("escape", "math_inline_block", inlineMathBlock),
        n &&
            e.inline.ruler.before(
                "text",
                "math_inline_bare_block",
                inlineBareBlock
            ),
        e.block.ruler.after(
            "blockquote",
            "math_block",
            (e, t, r, l) =>
                !(!n || !blockBareMath(e, t, r, l)) || blockMath(e, t, r, l),
            { alt: ["paragraph", "reference", "blockquote", "list"] }
        );
    const c =
            /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm,
        i =
            /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
    r &&
        e.core.ruler.push("math_block_in_html_block", (e) =>
            handleMathInHtml(e, "math_block", "$$", c)
        ),
        l &&
            e.core.ruler.push("math_inline_in_html_block", (e) =>
                handleMathInHtml(e, "math_inline", "$", i)
            );
    const o = (e) => {
            try {
                return `<p class="katex-block">${katex_1.default.renderToString(
                    e,
                    {
                        ...t,
                        displayMode: !0,
                    }
                )}</p>`;
            } catch (n) {
                return (
                    t?.throwOnError && console.log(n),
                    `<p class="katex-block katex-error" title="${escapeHtml(
                        e
                    )}">${escapeHtml(n + "")}</p>`
                );
            }
        },
        a = (e, t) => o(e[t].content) + "\n";
    if (
        ((e.renderer.rules.math_inline = (e, n) =>
            ((e) => {
                const n =
                    /\\begin\{(align|equation|gather|cd|alignat)\}/gi.test(e);
                try {
                    return katex_1.default.renderToString(e, {
                        ...t,
                        displayMode: n,
                    });
                } catch (n) {
                    return (
                        t?.throwOnError && console.log(n),
                        `<span class="katex-error" title="${escapeHtml(
                            e
                        )}">${escapeHtml(n + "")}</span>`
                    );
                }
            })(e[n].content)),
        (e.renderer.rules.math_inline_block = a),
        (e.renderer.rules.math_inline_bare_block = a),
        (e.renderer.rules.math_block = a),
        s)
    ) {
        const t = "math",
            n = e.renderer.rules.fence;
        e.renderer.rules.fence = function (e, r, l, c, i) {
            const a = e[r];
            return a.info.trim().toLowerCase() === t && s
                ? o(a.content) + "\n"
                : n?.call(this, e, r, l, c, i) || "";
        };
    }
}
exports.default = default_1;
//# sourceMappingURL=/sm/6836c7e3b2c174c66a2c5cfaef4323df604c88ddfe26e5207128971d191bf450.map
